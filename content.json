{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Freeb1e","url":"https://freeb1e.github.io","root":"/"},"pages":[{"title":"关于我","date":"2025-08-06T09:08:35.007Z","updated":"2025-08-06T09:08:35.007Z","comments":true,"path":"about.html","permalink":"https://freeb1e.github.io/about.html","excerpt":"","text":"你好！我是 Freeb1e 👋欢迎来到我的个人网站！这里是我的自我介绍： 职业：集成电路专业本科在读 兴趣爱好： 数字IC设计 理论力学 如果你想了解更多，欢迎通过社交媒体与我联系！😊"},{"title":"rf","date":"2025-07-12T16:03:31.000Z","updated":"2025-08-06T09:08:35.007Z","comments":true,"path":"rf/index.html","permalink":"https://freeb1e.github.io/rf/index.html","excerpt":"","text":"adsd"},{"title":"文章归档","date":"2025-08-06T09:08:35.007Z","updated":"2025-08-06T09:08:35.007Z","comments":true,"path":"archives.html","permalink":"https://freeb1e.github.io/archives.html","excerpt":"","text":""}],"posts":[{"title":"RV32FD1","slug":"RV32FD1","date":"2025-08-06T09:13:55.000Z","updated":"2025-08-06T09:18:24.784Z","comments":true,"path":"2025/08/06/RV32FD1/","permalink":"https://freeb1e.github.io/2025/08/06/RV32FD1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ZYNQ笔记1：ZYNQ GPIO的设置与初始化","slug":"ZYNQ1","date":"2025-07-17T05:10:34.000Z","updated":"2025-08-06T09:08:35.007Z","comments":true,"path":"2025/07/17/ZYNQ1/","permalink":"https://freeb1e.github.io/2025/07/17/ZYNQ1/","excerpt":"","text":"ZYNQ笔记1：ZYNQ GPIO的设置与初始化 1. GPIO寄存器与API对照表 功能 通道 Xil_底层操作 XGpio_高级API 数据寄存器 通道1 Xil_Out32(BASE + 0x0, data) XGpio_DiscreteWrite(&amp;inst, 1, data) 通道2 Xil_Out32(BASE + 0x8, data) XGpio_DiscreteWrite(&amp;inst, 2, data) 方向寄存器 通道1 Xil_Out32(BASE + 0x4, dir) XGpio_SetDataDirection(&amp;inst, 1, dir) 通道2 Xil_Out32(BASE + 0xC, dir) XGpio_SetDataDirection(&amp;inst, 2, dir) 数据读取 通道1 Xil_In32(BASE + 0x0) XGpio_DiscreteRead(&amp;inst, 1) 通道2 Xil_In32(BASE + 0x8) XGpio_DiscreteRead(&amp;inst, 2) 2. GPIO常用操作宏与初始化代码1234567891011// GPIO使能相关宏定义XGpio adc_prescale_en_gpio_inst;#define SET_ADC_EN XGpio_DiscreteWrite(&amp;adc_prescale_en_gpio_inst, 2, 1)#define CLR_ADC_EN XGpio_DiscreteWrite(&amp;adc_prescale_en_gpio_inst, 2, 0)// GPIO初始化XGpio_Initialize(&amp;adc_prescale_en_gpio_inst, XPAR_GPIO_0_DEVICE_ID);XGpio_SetDataDirection(&amp;adc_data_rd_gpio_inst, 1, 0xffff);XGpio_SetDataDirection(&amp;adc_data_rd_gpio_inst, 2, 0);Xil_In32(XPAR_AXI_GPIO_5_BASEADDR + XGPIO_DATA_OFFSET);Xil_Out32(GPIO_3_BASEADDR + 0x4, 0x00000000); 3. GPIO初始化函数示例1234567891011121314151617void gpio_init(void)&#123; // GPIO3: rst_n和en信号 Xil_Out32(GPIO_3_BASEADDR + 0x0, 0x00000000); // 通道1数据初始化 Xil_Out32(GPIO_3_BASEADDR + 0x4, 0x00000000); // 通道1方向：输出 Xil_Out32(GPIO_3_BASEADDR + 0x8, 0x00000000); // 通道2数据初始化 Xil_Out32(GPIO_3_BASEADDR + 0xC, 0x00000000); // 通道2方向：输出 // GPIO4: freq_word和output_mode Xil_Out32(GPIO_4_BASEADDR + 0x0, 0x00000000); // 通道1数据初始化 Xil_Out32(GPIO_4_BASEADDR + 0x4, 0x00000000); // 通道1方向：输出 Xil_Out32(GPIO_4_BASEADDR + 0x8, 0x00000000); // 通道2数据初始化 Xil_Out32(GPIO_4_BASEADDR + 0xC, 0x00000000); // 通道2方向：输出 // GPIO5: final_valid输入 Xil_Out32(GPIO_5_BASEADDR + 0x4, 0x00000001); // 通道1方向：输入&#125; 4. GPIO寄存器宏定义（xgpio.h）123456789101112131415161718192021222324252627282930#ifndef XGPIO_L_H#define XGPIO_L_H#include &quot;xil_types.h&quot;#include &quot;xil_assert.h&quot;#include &quot;xil_io.h&quot;#define XGPIO_DATA_OFFSET 0x0 // 数据寄存器（通道1）#define XGPIO_TRI_OFFSET 0x4 // 方向寄存器（通道1）#define XGPIO_DATA2_OFFSET 0x8 // 数据寄存器（通道2）#define XGPIO_TRI2_OFFSET 0xC // 方向寄存器（通道2）#define XGPIO_GIE_OFFSET 0x11C // 全局中断使能寄存器#define XGPIO_ISR_OFFSET 0x120 // 中断状态寄存器#define XGPIO_IER_OFFSET 0x128 // 中断使能寄存器#define XGPIO_CHAN_OFFSET 8 // 通道偏移#define XGPIO_IR_MASK 0x3 // 所有中断位掩码#define XGPIO_IR_CH1_MASK 0x1 // 通道1中断位掩码#define XGPIO_IR_CH2_MASK 0x2 // 通道2中断位掩码#define XGPIO_GIE_GINTR_ENABLE_MASK 0x80000000 // 全局中断使能掩码#define XGpio_In32 Xil_In32 // 输入操作#define XGpio_Out32 Xil_Out32 // 输出操作#define XGpio_WriteReg(BaseAddress, RegOffset, Data) \\ XGpio_Out32((BaseAddress) + (RegOffset), (u32)(Data))#define XGpio_ReadReg(BaseAddress, RegOffset) \\ XGpio_In32((BaseAddress) + (RegOffset))#endif","categories":[{"name":"电赛","slug":"电赛","permalink":"https://freeb1e.github.io/categories/%E7%94%B5%E8%B5%9B/"}],"tags":[{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://freeb1e.github.io/tags/ZYNQ/"}]},{"title":"2024E","slug":"2024E","date":"2025-07-12T17:23:44.000Z","updated":"2025-08-06T09:08:35.006Z","comments":true,"path":"2025/07/13/2024E/","permalink":"https://freeb1e.github.io/2025/07/13/2024E/","excerpt":"","text":"三子棋游戏装置摘要：本设计实现了一种基于视觉识别的三子棋游戏装置，具备机械臂自动落子、智能对弈及防悔棋等功能。系统采用模块化设计，由三大核心部分组成： 控制模块：STM32微控制器与六轴机械臂协同工作。 图像识别模块：树莓派搭载高精度摄像头实现棋盘状态检测。 人机交互模块：串口屏提供可视化操作界面。 用户通过串口屏触发游戏指令后，图像识别模块实时扫描棋盘信息，并通过串口通信控制机械臂执行预编程动作组，完成高精度落子操作。该系统融合了计算机视觉与机电控制技术，实现了三子棋对弈的自动化与智能化。关键词：计算机视觉；树莓派；六轴机械臂；动作组编程；STM32；人机交互 二、程序设计1. 棋子位置的图像识别设计图像识别的关键是准确地将拍摄到的棋子的位置映射到三子棋九宫格的棋盘之上。我们设计的图像处理步骤主要分为两步： 提取所拍摄图像的棋盘区域。 在棋盘区域内识别棋子信息。 1.1 提取所拍摄图像的棋盘区域1.1.1 预处理与寻找最大矩形设计 getContours 函数，将图像灰度化、模糊、Canny 边缘检测，然后膨胀和腐蚀，提取外部轮廓。在提取到的所有矩形轮廓中，选取最大的矩形轮廓作为棋域。 1.1.2 从视频中截取出矩形区域设计 recoder 函数，对识别为棋盘的矩形区域的四个顶点进行排序，确保顺序为左上、右上、左下、右下。这样可以使得矩形在提取过后的朝向确定。 1.1.3 透视变换设计 warpImg 函数，利用排序后的顶点和目标宽高，计算透视变换矩阵，将棋盘区域裁剪并拉正为标准正方形状，并规定画面大小为 300×300。这样的操作不仅可以精简下一步的识别区域，降低对于摄像头精确位置的依赖，也有助于减少因为摄像头倾斜等问题造成的识别误差。 1.2 在棋盘边沿内识别棋子信息1.2.1 圆检测使用 OpenCV 库自带函数 cv2.HoughCircles 提取经过预处理后的图像中的圆形轮廓。在检测的过程中调节函数参数，根据棋子的大小设置只保留画布中半径大小在 20 到 50 像素的圆形，并且抛弃圆心距离在 20 像素以内的圆形。能够起到非常精确的检测圆形的效果。 1.2.2 棋子颜色判定为了提高判定的精准性，取检测到的棋子圆心坐标的范围之内的像素的亮度进行加权平均作为棋子颜色的特征，用 100 作为阈值可以分辨出黑子和白子。 1.2.3 棋子坐标的判定遍历每个圆，取其圆心坐标，通过整除 100 并加 1 的方法将像素坐标映射到棋盘的行列索引。 2. 三子棋对弈程序的设计2.1 人机对弈算法的设计由于井字棋具有游戏必须是有限步数、完全信息、零和且双方轮流行动的特点，故使用 Minimax 算法能够非常精确地找出机器端所能做出的最佳决策。设计 minmax 函数，会递归地遍历当前棋盘所有可能的落子情况： 首先寻找所有空位，然后依次尝试每一个空位的落子。 每次落子后递归调用自身，切换到对方玩家，继续模拟后续所有可能的对局发展。 每当遇到终局（胜负或平局），就返回一个分值（如电脑胜利返回 1，玩家胜利返回 -1，平局返回 0）。 递归返回时，电脑（’X’）会选择分值最大的步骤，玩家（’O’）会选择分值最小的步骤，这样保证每一步都做出对自己最有利的选择。为了让对局结果不显单调，我们会找出所有相同优秀的步骤，然后在可供选择的步骤里面进行随机选择，提高了对局的丰富性。 2.2 悔棋检测设置 buffer 对上一次对弈之后的棋盘进行存储，并且只保留机器落下的棋子。在下一次轮到机器下棋之前进行检测，通过寻找存储字符串之间的差异就可以找出唯一被移动的棋子进行还原。 三、硬件平台搭建设计3.1 摄像头与机械臂的固定将摄像头的位置高度经图像程序测定后固定，确保视野覆盖良好，机械臂与摄像头定位确保无冲突，可固定抓取。 3.2 棋盘选择经图像程序识别，得到绿色的棋盘效果较良好。 3.3 棋子摆放设计棋子摆放的凹槽，可以确保棋子摆放的位置，将黑白棋子分别放在两侧。 3.4 棋子棋盘建模 四、硬件各部分的串口通信协议如图，本系统利用 STM32 的 3 个串口实现多模块协同控制： UART1：负责与树莓派通信，传输指令触发摄像头识别流程。具体表现为：当游戏启动时，STM32 发送识别指令至树莓派，树莓派完成图像识别后回传目标动作组编号。 UART3：用于驱动机械臂，STM32 将接收到的动作组编号转发至机械臂控制器，调用其预存的动作组完成精准落子。 UART6：连接串口屏实现人机交互，用户点击 “开始下棋” 按钮后，STM32 通过该接口同步触发树莓派识别流程，并在机械臂动作执行期间，实时更新运行时间至串口屏显示，增强操作可视性。 五、性能测试5.1 测试环境正常室内照明环境，无特殊照明条件要求。 5.2 测试方案5.2.1 图像识别测试方案分别将黑色棋子和白色棋子放置在棋盘的九个位置上进行测试。 5.2.2 机械臂动作组测试方案 测试机械臂的动作组是否准确将棋子从初始位置放置到棋盘的九个位置上。 测试机械臂的动作组是否准确将棋子从棋盘上的任意一个位置移动到另外一个位置。 5.2.3 人机对弈测试方案 人先手下棋对弈测试。 机先手下棋对弈测试。 反复悔棋测试。 5.3 测试结果分析5.3.1 图像识别测试经测试，由树莓派和摄像头构成的图像识别模块能够准确地识别判断出棋盘上各个棋子的位置和颜色。 5.3.2 机械臂动作组测试 经测试，机械臂能够将棋子从棋盘外抓取，精确地放置于棋盘内正确的位置，且不会压到黑色实线。 经测试，机械臂能够精确地将棋子从棋盘内一个位置抓取到棋盘内另一个位置，且不会碰到其他棋子。 经测试，机械臂能够将人移动的棋子移回原位，且不会碰到其他棋子。 5.3.3 人机对弈测试 经测试，装置在先手的情况下，若人第一步下错，装置可以保证赢棋。 在后手的情况下，装置可以保证不输棋。 六、参考文献 罗杰,谢自美.电子线路-设计·实验·测试(第五版),2015,电子工业出版社. 康华光.电子技术基础(模拟部分)(第六版).2013,高等教育出版社. [美]Bruce Carter.运算放大器权威指南(第四版)2014,人民邮电出版社. 全国大学生电子设计竞赛组委会.第十一届全国大学生电子设计竞赛获奖作品选编,北京理工大学出版社.","categories":[{"name":"电赛","slug":"电赛","permalink":"https://freeb1e.github.io/categories/%E7%94%B5%E8%B5%9B/"}],"tags":[{"name":"opencv python","slug":"opencv-python","permalink":"https://freeb1e.github.io/tags/opencv-python/"}]},{"title":"Hello World","slug":"hello-world","date":"2025-07-11T16:00:00.000Z","updated":"2025-08-06T09:08:35.007Z","comments":true,"path":"2025/07/12/hello-world/","permalink":"https://freeb1e.github.io/2025/07/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"网页前端","slug":"网页前端","permalink":"https://freeb1e.github.io/categories/%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"html","slug":"html","permalink":"https://freeb1e.github.io/tags/html/"}]}],"categories":[{"name":"电赛","slug":"电赛","permalink":"https://freeb1e.github.io/categories/%E7%94%B5%E8%B5%9B/"},{"name":"网页前端","slug":"网页前端","permalink":"https://freeb1e.github.io/categories/%E7%BD%91%E9%A1%B5%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"ZYNQ","slug":"ZYNQ","permalink":"https://freeb1e.github.io/tags/ZYNQ/"},{"name":"opencv python","slug":"opencv-python","permalink":"https://freeb1e.github.io/tags/opencv-python/"},{"name":"html","slug":"html","permalink":"https://freeb1e.github.io/tags/html/"}]}